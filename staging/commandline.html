
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Yeoman - Modern workflows for modern webapps</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <link href='http://fonts.googleapis.com/css?family=Droid+Sans|Lekton|Ubuntu+Mono:400,700' rel='stylesheet' type='text/css'>
  <link href="css/normalize.css" rel="stylesheet" />
  <link href="css/yeoman.css" rel="stylesheet" />
  <link href="css/prettify.css" rel="stylesheet" />

  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
  <script src="js/libs/prettify.js"></script>
  <script src="js/script.js"></script>
</head>

<body>


    <nav>
    <header><a href="index.html"><img src="img/yeoman-logo.png" /></a></header>
    <ul>
      <li class="nav-divider"><a href="index.html"><img src="img/icon-home.png" />Home</a></li>
      <li><a href="whyyeoman.html"><img src="img/icon-why-yeoman.png" />Why Yeoman?</a></li>
      <li><a href="gettingstarted.html"><img src="img/icon-getting-started.png" />Getting Started</a></li>
      <li><img src="img/icon-documentation.png" />Documentation</li>
      <li class="nav-sub"><a href="commandline.html">Command Line</a></li>
      <li class="nav-sub nav-divider"><a href="packagemanager.html">Package Manager</a></li>
      <li><a href="faq.html"><img src="img/icon-faqs.png" />FAQs</a></li>
      <li class="nav-divider"><img src="img/icon-discuss.png" /><a href="https://groups.google.com/forum/?fromgroups#!forum/yeoman-dev">Discuss</a></li>
      <li><a href="https://plus.google.com/101063139999404044459/posts"><img src="img/icon-google-plus.png" />Google Plus</a></li>
      <li class="nav-divider"><a href="http://twitter.com/yeoman"><img src="img/icon-twitter.png" />Twitter</a></li>
      <li><a href="http://github.com/yeoman/yeoman"><img src="img/icon-github.png" />GitHub</a></li>
      <li><a href="https://github.com/yeoman/yeoman/#contribute"><img src="img/icon-contributing.png" />Contributing</a></li>
    </ul>
  </nav>

     <div id="content">
    <article><h1>COMMAND LINE</h1>

<p>The Yeoman Command-Line Interface (CLI) provides access to most of our features. In this section, you can learn about the various commands supported, about our generator system and many other topics related to creating and building projects with Yeoman.</p>

<h2>Commands &amp; Topics</h2>

<ul>
<li><a href="#help">help</a></li>
<li><a href="#init">init</a></li>
<li><a href="#build">build</a></li>
<li><a href="#server">server</a></li>
<li><a href="#test">test</a></li>
<li><a href="#help">help</a></li>
<li><a href="#generator">generator</a></li>
<li><a href="#modules">modules</a></li>
<li><a href="#install">install</a></li>
<li><a href="#update">update</a></li>
<li><a href="#search">search</a></li>
<li><a href="#list">list</a></li>
<li><a href="#lookup">lookup</a></li>
<li><a href="#uninstall">uninstall</a></li>
</ul>

<h2><a href="#help" name="help">help</a></h2>

<ul>
<li><code>yeoman --help</code> or <code>yeoman help</code></li>
</ul>

<p>Lists out the commands and tasks supported by yeoman and should print out the following to the console:</p>

<pre><code>
yeoman init      # Initialize and scaffold a new project using generator templates
yeoman build     # Build an optimized version of your app, ready to deploy
yeoman server    # Launch a preview server which will begin watching for changes
yeoman test      # Run a Mocha test harness in a headless Phantom.js

yeoman install   # Install a package from the clientside package registry
yeoman uninstall # Uninstall the package
yeoman update    # Update a package to the latest version
yeoman list      # List the packages currently installed
yeoman search    # Query the registry for matching package names
yeoman lookup    # Look up info on a particular package
</code></pre>

<p>Note that commands may also support additional flags and so we recommend consulting the documentation for specific<br />commands for the complete details.</p>

<h2><a href="#init" name="init">init</a></h2>

<p>Usage: <code>yeoman init</code>, <code>yeoman init generatorName</code>, <code>yeoman init generatorName:subgenerator</code></p>

<p>Helps you kick-start a new web application by asking a number of questions about what you would like to include.<br />These answers are used to scaffold out a file structure for your project.</p>

<p>The init template is based on:</p>

<ul>
<li>HTML5 Boilerplate for the main base</li>
<li>Compass Twitter Bootstrap for the SASS files as the CSS files are authored in SASS</li>
<li>Twitter Bootstrap for the optional list of JavaScript plugins (optional)</li>
<li>RequireJS for AMD module and script loading support (optional)</li>
<li>RequrieHM for experimental EcmaScript 6 module syntax support on top of RequireJS (optional)</li>
</ul>

<p>By default we support Compass and CoffeeScript, so if your project includes any .coffee files, these will be<br />compiled when either <code>server</code> or <code>build</code> tasks are being run.</p>

<p>If everything has been installed successfully, running <code>yeoman init</code> will present you with a welcome<br />screen to kick off your project that looks a little like this:</p>

<pre><code>
        _   .--------------------------.
      _|o|_ |    Welcome to Yeoman,    |
       |_|  |   ladies and gentlemen!  |
     / \Y/ \ o_________________________|
    ||  :  |//
    o/ --- \
      _\ /_


.. Invoke app ..

Please answer the following:
[?] Would you like to include Twitter Bootstrap for Compass? (Y/n)
</code></pre>

<h3>custom generators</h3>

<p>Some of our supported custom generators include:</p>

<pre><code>
yeoman init bbb      #backbone boilerplate
yeoman init angular  #angularjs seed
yeoman init ember    #ember app based on ember-rails
</code></pre>

<p>Yeoman comes with a powerful system of Generators for scaffolding out applications using any number<br />of boilerplates, frameworks and dependencies. Generators can be called in a project which has already<br />been initialized with a basic Yeoman application structure OR may contain all of the files needed for the<br />application structure themselves. By default, one can call a generator as follows:</p>

<pre><code>
yeoman init generatorName:subgenerator #e.g init angular:all
</code></pre>

<p>In the case of a Generator named "angular", a grouping sub-generator called <code>all</code> may exist for scaffolding<br />out all of the files needed for a new AngularJS application. One would use this as follows:</p>

<pre><code>
yeoman init angular:all
</code></pre>

<p>The idea here is that the Generator would pull in AngularJS, its common dependencies and write out the<br />boilerplate needed for a basic Controller and any other components the framework may require.</p>

<p>As we understand that it's unlikely a user will wish to manually type out the ":all" part of each generator, we support a catch-"all". If a generator has a sub-generator (grouper) called "all" we will attempt to call "all" when you try running the top-level generator. This allows a user to simply call:</p>

<pre><code>
yeoman init angular
</code></pre>

<p>and has it defer to <code>angular:all</code> automatically.</p>

<p>If one then wishes to create further AngularJS controllers, one can simply call the 'controller' sub-generator as<br />follows:</p>

<pre><code>
yeoman init angularjs:controller controllerName
</code></pre>

<p>where <code>controllerName</code> is the name of the Controller you wish to create.</p>

<p>Similarly, a Backbone.js Generator may be used as follows:</p>

<pre><code>
yeoman init backbone
</code></pre>

<p>where the above would result in boilerplate for models, views, collections and a router being written to<br />the current application directory, as well as Backbone.js and its dependencies being pulled in. One could<br />then call the different sub-generators for the Generator as follows:</p>

<pre><code>
yeoman init backbone:model modelName
yeoman init backbone:collection collectionName
yeoman init backbone:view viewName
yeoman init backbone:router routerName
</code></pre>

<p>To list out all of the generators currently available locally, you can use the <code>--help</code> flag as follows:</p>

<pre><code>
yeoman init --help
</code></pre>

<p>This will print out a list of existing generators as follows:</p>

<pre><code>
Please choose a generator below.

Yeoman:
  generator
  controller

Ember:
  ember:all
  ember:controller
  ember:model
  ember:view

Backbone:
  backbone:all
  backbone:model
  backbone:router
  backbone:view
  backbone:collection
</code></pre>

<h2><a href="#build" name="build">build</a></h2>

<p>Usage: <code>yeoman build</code>, <code>yeoman build:&lt;target&gt;</code></p>

<p>Constructs an optimized version of your application that's ready to deploy.</p>

<p>Yeoman makes use of <a href="https://github.com/cowboy/grunt">Grunt</a> behind the scenes to tackle much of the hard work for this, with some useful additions that assist with compression, optimization and testing. </p>

<p>These include:</p>

<ul>
<li>Linting all JavaScript files against JSHint</li>
<li>Recompiling all CoffeeScript and SASS files for production</li>
<li>Using r.js to compile and optimize any AMD modules</li>
<li>Concatenation and minification of scripts and stylesheets</li>
<li>Compressing your images using OptiPNG for PNG files and JPEGtran-turbo for JPEGs</li>
<li>Running any unit tests written against a headless WebKit browser (via PhantomJS)</li>
<li>Creating an Application Cache manifest via Confess.js</li>
<li>Using revision filenames or oldernames</li>
</ul>

<p>Much of the build configuration information for a project is placed inside 'Gruntfile.js', a file which we automatically create when you generate a new project using Yeoman. This file can be fully customized to support which paths you wish to watch, have compiled (should they contain Compass or CoffeeScript files) and so on.</p>

<p>When you run <code>yeoman server</code>, we generate an intermediate build directory called <code>temp</code>, containing compiled versions of your Compass and CoffeeScript files as well as all of the other files needed to preview your application. Running <code>yeoman build</code> creates a <code>dist</code> directory which has completely optimized version of your application that can be deployed to staging.</p>

<h3>Build targets</h3>

<p>Yeoman supports a number of build targets to be used with <code>yeoman build</code>. To implicitly<br />pass the <code>default</code> target one would run <code>yeoman build:default</code> for example. The complete<br />list of supported build targets can be found below:</p>

<ul>
<li>default: Runs <code>concat css min img rev usemin manifest</code></li>
<li>text: Runs <code>concat css min rev usemin manifest</code></li>
<li>buildkit: Runs <code>concat css min img rev usemin manifest html:buildkit</code></li>
<li>basics: Runs <code>concat css min img rev usemin manifest html:basics</code></li>
<li>minify: Runs <code>concat css min img rev usemin manifest html:compress</code></li>
</ul>

<h3>Sub-tasks</h3>

<p>Each build target above runs a number of different build <em>tasks</em>. The supported<br />tasks included with Yeoman out of the box are:</p>

<ul>
<li>clean: Wipe the previous build dirs</li>
<li>copy: Copies the whole staging(intermediate/) folder to output (publish/) one</li>
<li>css: Concatenates, replaces @imports and minifies the CSS files</li>
<li>dom: DOM-based build system</li>
<li>html: Basic to aggressive HTML minification</li>
<li>img: Optimizes .png/.jpg images using OptiPNG/JPEGtran</li>
<li>mkdirs: Prepares the build dirs</li>
<li>rev: Automate the hash renames of assets filename</li>
<li>usemin: Replaces references to non-minified scripts / stylesheets</li>
</ul>

<h3>Require.js / r.js configuration</h3>

<p>Yeoman has a special task that automatically handles the optimization of Require.js/AMD<br />projects using the r.js optimizer. Configuration for this optimization (i.e your r.js<br />configuration) should be done within the <code>rjs</code> section of the Gruntfile for a project.</p>

<p>You can either do this at a project level by editing your projects Gruntfile or do this<br />at a generator level if you would rather avoid editing the Gruntfile outside of the default<br />setup each time.</p>

<p>The following is the relevant block to edit within your Gruntfile: </p>

<pre><code>
    // rjs configuration. You don't necessarily need to specify the typical
    // `path` configuration, the rjs task will parse these values from your
    // main module, using <a href='http://requirejs.org/docs/optimization.html#mainConfigFile'>http://requirejs.org/docs/optimization.html#mainConfigFile</a>
    //
    // name / out / mainConfig file should be used. You can let it blank if
    // you're using usemin-handler to parse rjs config from markup (default
    // setup)
    rjs: {
      // no minification, is done by the min task
      optimize: 'none',
      baseUrl: './scripts',
      wrap: true
   }
</code></pre>

<p>See the official project <a href="https://github.com/jrburke/r.js">repo</a> for more information on the <br />options supported by r.js.</p>

<h2><a href="#server" name="server">server</a></h2>

<p>Usage: <code>yeoman server</code></p>

<p>Launches a preview server on port 3051 that allows you to access a running version of your application<br />locally.</p>

<p>It also automatically fires up the <code>yeoman watch</code> process, so changes to any of the applications<br />files cause the browser to refresh via <a href="http://livereload.com">LiveReload</a>. Should you not have<br />LiveReload installed locally, a fallback reload process will be used instead.</p>

<p>Any changes to CoffeeScript or Compass files result in them being recompiled, meaning that<br />no manual intervention is required to write and preview code in the format you feel most<br />comfortable with.</p>

<p><code>yeoman server</code> generates an intermediate build directory in your project root which (called <code>temp</code>)<br />contains the compiled files mentioned above as well as the basic blocks needed to preview your application.<br />A complete build can be generated using <code>yeoman build</code>.</p>

<p>To quit the server, simply run <code>yeoman quit server</code> and this will kill the Python server<br />process.</p>

<h3>profiles</h3>

<p>The built-in server also supports serving different profiles of your application, such as: <code>app</code>, <code>dist</code>, <code>test</code> and <code>reload</code>.</p>

<ul>
<li><code>yeoman server</code> and <code>server:app</code> compile to and serve <code>/temp</code>, an intermediate build of your application.</li>
<li><code>yeoman server:dist</code> serves up the optimized final version of your application. This will just serve up the <code>/dist</code> directory if it exists and you will need to run <code>yeoman build</code> in order to generate the production build of your app.</li>
<li><code>yeoman server:test</code> serves up the test suite</li>
<li><code>yeoman server:reload</code> forces the port to be LiveReload standard port: 35729 and prevents the automatic default browser opening. Handy for those wishing to use livereload extensions with other systems / HTTP servers than the one provided by Yeoman out of the box.</li>
</ul>

<h3>further notes</h3>

<p>At present, when initially running <code>yeoman server</code> or <code>yeoman server:app</code>, some users may find that their browser is opened before intermediate files such as Compass and CoffeeScript have completed compiling. Whilst we intend on fixing this issue very soon, in the mean time we recommend refreshing the browser shortly after you first fire up the server (e.g 10 seconds after). You can then easily make any changes you wish to your application and the browser will be automatically reloaded via LiveReload.</p>

<h2><a href="#test" name="test">test</a></h2>

<p>Usage: <code>yeoman test</code></p>

<p>Runs a Mocha test harness in a headless instance of Phantom.js.</p>

<p>When you generate a new project using <code>yeoman init</code>, we also scaffold out a basic set of<br />Mocha unit tests that you can continue using to test your application.</p>

<p>Running <code>yeoman test</code> allows you to easily check if all of your tests are passing. This also<br />gets called when running <code>yeoman build</code>.</p>

<p>Example:</p>

<pre><code>
yeoman test

# outputs:

Running "mocha:all" (mocha) task
Running specs for index.html
.....................................................
>> 82 assertions passed in 53 specs (562ms)

Done, without errors.
</code></pre>

<h2><a href="#install" name="install">install</a></h2>

<p>Usage: <code>yeoman install &lt;packageName&gt;</code>, <code>yeoman install &lt;package1&gt; &lt;package2&gt;</code></p>

<p>Installs a package <name> and any packages that this depends on using Twitter Bower. A package is a folder containing a resource described by a package.json file or a gzipped tarball containing this information.</p>

<p>Running yeoman install <name> will install the dependencies in your projects browser_modules folder.</p>

<p>Example:</p>

<pre><code>
yeoman install jquery
yeoman install jquery spine
</code></pre>

<p>If installing a dependency which has its own dependencies described, these dependencies will also be pulled in.</p>

<p>Example:</p>

<pre><code>
yeoman install backbone
</code></pre>

<p>will actually also install Underscore.js and jQuery.js as these are required for Backbone to function correctly.</p>

<p><code>yeoman install</code> also supports installing packages using more than just the package name. Namely:</p>

<pre><code>
bower install jquery
bower install git://github.com/maccman/package-jquery.git
bower install <a href='http://code.jquery.com/jquery-1.7.2.js'>http://code.jquery.com/jquery-1.7.2.js</a>
bower install ./repos/jquery
</code></pre>

<h2>Available Packages</h2>

<p>Currently available packages:</p>

<ul>
<li><strong>backbone</strong> <em>git://github.com/paulirish/package-backbone.git</em></li>
<li><strong>jquery-ui</strong> <em>git://github.com/maccman/package-jquery-ui.git</em></li>
<li><strong>jquery</strong> <em>git://github.com/maccman/package-jquery.git</em></li>
<li><strong>knockout</strong> <em>git://github.com/SteveSanderson/knockout.git</em></li>
<li><strong>modernizr</strong> <em>git://github.com/josh/package-modernizr.git</em></li>
<li><strong>spine</strong> <em>git://github.com/maccman/spine.git</em></li>
<li><strong>underscore</strong> <em>git://github.com/paulirish/package-underscore.git</em></li>
</ul>

<p>For further information, see the section on the package manager.</p>

<h2><a href="#list" name="list">list</a></h2>

<p>Usage: <code>yeoman list</code></p>

<p>Lists all of the packages that have been installed using <code>yeoman install</code> (Bower) in your current project.</p>

<p>Example:</p>

<pre><code>
# If you have previously called
yeoman install backbone

# and then run
yeoman list

# the output will be

/myapp/
├─┬ backbone#0.9.2
│ ├── jquery#1.7.2
│ └── underscore#1.3.3
├── jquery#1.7.2
└── underscore#1.3.3
</code></pre>

<p>As you can see, this also includes the version information for each package and its dependencies.</p>

<h2><a href="#lookup" name="lookup">lookup</a></h2>

<p>Usage: <code>yeoman lookup &lt;packageName&gt;</code></p>

<p>Performs a lookup in the Bower registry for a package of a specific name. One would use this to confirm<br />that a package exists under a specific name (e.g <code>jquery</code>), othewise <code>search</code> should be used for broader queries.</p>

<p>Example:</p>

<pre><code>
yeoman lookup jquery

# outputs

jquery git://github.com/maccman/package-jquery.git
</code></pre>

<h2><a href="#search" name="search">search</a></h2>

<p>Usage: <code>yeoman search &lt;keyword&gt;</code></p>

<p>Searches the Bower registry for packages which include a specific keyword in their name.</p>

<p>Example:</p>

<pre><code>
yeoman search jquery

# outputs

Search results:

  - jquery git://github.com/maccman/package-jquery.git
  - jquery-ui git://github.com/maccman/package-jquery-ui.git
  - jquery-infinite-scroll git://github.com/paulirish/infinite-scroll.git

</code></pre>

<h2><a href="#update" name="update">update</a></h2>

<p>Usage: <code>yeoman update &lt;packageName&gt;</code></p>

<p>Updates an already installed package <packageName> to the latest version available in the Bower registry.</p>

<p>Example:</p>

<pre><code>
yeoman update jquery

# outputs
bower checking out jquery#v1.7.2
</code></pre>

<p>The <code>update</code> command will also update any other packages in your project relying on this dependency to use<br />this most recent version if any update is applied.</p>

<h2><a href="#uninstall" name="uninstall">uninstall</a></h2>

<p>Usage: yeoman uninstall <packageName></p>

<p>Removes the package <packageName> from the current project.</p>

<p>Example:</p>

<pre><code>
yeoman uninstall backbone

# outputs:

bower uninstalling /project/browser_modules/backbone
</code></pre>

<p>Note: If you attempt to uninstall a package that is a dependency of other packages, yeoman (via Bower)<br />will throw an error.</p>

<p>Example:</p>

<pre><code>
yeoman uninstall jquery

# outputs:
warning backbone depends on jquery
</code></pre>

<p>This simply means that you should uninstall backbone (the top-level package with the dependency) if you<br />wish to remove all traces of the jquery package.## <a href="#generators" name="generators">generators</a></p>

<p>Generator templates allow you to scaffold out a project using a custom setup of boilerplates, frameworks and dependencies. The basic application generated when calling <code>yeoman init</code> actually uses a generator itself and they can be quite powerful. </p>

<p>Some of the generators Yeoman includes out of the box include implementations for Backbone.js, Ember.js and Angular.js. These allow you to not only use complete boilerplates for an application but also scaffold out smaller parts such as Models, Views, Controllers and so on. </p>

<h3>Getting Started</h3>

<h2>yeoman init generator</h2>

<p>The <code>yeoman init</code> command uses templates and prompts to create the files needed for a project.</p>

<p>Running <code>yeoman init --help</code> by itself gives a list of available generators:</p>

<pre><code>$ yeoman init generator
Usage: yeoman init generator GENERATOR [args] [options]

...
...

Please choose a generator below.

Yeoman:
  controller
  generator
  ...
  ...
</code></pre>

<p><strong>Note</strong>: You can install more generators through npm package and you can even create your own.<br />Yeoman's own generators are available in a dedicated <a href="https://github.com/yeoman/generators">repository</a>.<br />Using generators will save you a large amount of time by writing boilerplate code, code that is necessary for the app to work.</p>

<p>Let's make our own controller with the controller generator. But what command should we use?  Let's ask the generator:</p>

<p><strong>Note</strong>: Generators available may have help text. You can try adding --help or<br />-h to the end, for example <code>yeoman generate controller --help</code></p>

<pre><code>.. Invoke controller ..
Usage:
  yeoman init generator controller NAME one two three [options]

Options:
  -h, --help          # Print generator's options and usage
      --js-framework  # Js framework to be invoked
                      # Default: ember
</code></pre>

<p>The controller generator is expecting parameters in the form of <code>generate controller ControllerName action1 action2</code></p>

<p>Let's make a <code>Greeting</code> controller with an action of <code>hello</code>.</p>

<pre><code>$ yeoman init generator controller Greeting hello
</code></pre>

<p>What did this generate? It made sure a bunch of directories where in our application, and created a controller file, a view file and / or template file and a test file.</p>

<p>Yeoman comes with a generator for data models too.</p>

<pre><code>$ yeoman init generator model
</code></pre>

<h2>Creating and Customizing Yeoman Generators &amp; Templates</h2>

<ol>
<li>First Contact</li>
<li>Creating Your First Generator</li>
<li>Creating Generators with Generators</li>
<li>Generators Lookup</li>
<li>Customizing Your Workflow</li>
<li>Customizing Your Workflow by Changing Generators Templates</li>
<li>Adding Generators Fallbacks</li>
<li>Application Templates</li>
</ol>

<h3>First contact</h3>

<p>When you create an application using the <code>yeoman init</code> command, you are in fact<br />using a Yeoman generator. After that, you can get a list of all available<br />generators by just invoking <code>yeoman init --help</code>:</p>

<pre><code>$ yeoman init
$ cd app
$ yeoman init --help
</code></pre>

<p>You will get a list of all generators that come with yeoman. If you need a detailed description for a given generator, you can simply do:</p>

<pre><code>$ yeoman init generator [generator] --help
</code></pre>

<h3>Creating Your First Generator</h3>

<p>Generators are built on top of Grunt. Grunt provides powerful options parsing and a great API for manipulating files. For instance, let’s build a generator that creates an initializer file named initializer.js inside <code>app/js/</code></p>

<p>The first step is to create a file at `lib/generators/initializer/index.js with<br />the following content:</p>

<pre><code>var util = require('util'),
    yeoman = require('../../../');

module.exports = Generator;

function Generator() {
  yeoman.generators.Base.apply(this, arguments);
}

util.inherits(Generator, yeoman.generators.Base);

Generator.prototype.createInitializerFile = function() {
  this.write('app/js/initializer.js', "// Add initialization content here\n");
};
</code></pre>

<p><code>write</code> is a method provided by <code>yeoman.generators.Base</code>, and is a basic facade to the <code>grunt.file</code> API. When we "write" things, this happen relative to the<br />working directory (that is the Gruntfile location, the Gruntfile is resolved internally, walking up the FS until one is found. This is most likely the root<br />of the yeoman application).</p>

<p>Our new generator is quite simple: it inherits from <code>yeoman.generators.Base</code> and has one method definition. Each "public" method in the generator is<br />executed when a generator is invoked (first level method in the prototype chain, eg.  <code>Base</code> class method are not called). There are two exceptions,<br />generators won't run:</p>

<ul>
<li>any method begining with the <code>_</code> prefix.</li>
<li>a <code>constructor</code> method, specifically used with generators written in
CoffeeScript</li>
</ul>

<p>Finally, we invoke the <code>write</code> method that will create a file at the given destination with the given content.</p>

<p><strong>Note</strong>: Generators should execute their tasks synchronously. We currently lack the API to be able to do things asynchronously (which we might need). A<br /><code>this.async()</code> method should be implemented, which returns a new handler to call on completion.</p>

<p>Now, we can see that the initializer generator available to use if we output<br />the list of available generators in this application:</p>

<pre><code>$ yeoman init generator

Usage: yeoman generate GENERATOR [args] [options]
...

Please choose a generator below.

...

Initializer:
  initializer
</code></pre>

<p>To invoke our new generator, we just need to do:</p>

<pre><code>$ yeoman init initializer
</code></pre>

<p>Before we go on, let’s see our brand new generator description:</p>

<pre><code>$ yeoman generate initializer --help
.. Invoke initializer ..
Description:
    Create files for initializer generator.
</code></pre>

<p>Yeoman is usually able to generate good descriptions, but not in this particular<br />case. We can solve this problem in two ways. The first one is calling desc<br />inside our generator:</p>

<pre><code>var util = require('util'),
    yeoman = require('../../../');

module.exports = Generator;

function Generator() {
  yeoman.generators.Base.apply(this, arguments);

  this.desc('This generator creates an initializer file at app/js/');
}

util.inherits(Generator, yeoman.generators.Base);

Generator.prototype.createInitializerFile = function() {
  this.write('app/js/initializer.js', "// Add initialization content here");
};
</code></pre>

<p>Now we can see the new description by invoking --help on the new generator. The second way to add a description is by creating a file named <code>USAGE</code> in the same directory as our generator. We are going to do that in the next step.</p>

<h3>Creating Generators with Generators</h3>

<p>Generators themselves have a generator:</p>

<pre><code>$ yeoman init generator generator initializer
  create  lib/generators/initializer
  create  lib/generators/initializer/index.js
  create  lib/generators/initializer/USAGE
  create  lib/generators/initializer/templates
</code></pre>

<p>This is the generator just created:</p>

<pre><code>var util = require('util'),
    yeoman = require('../../../');

module.exports = Generator;

function Generator() {
  yeoman.generators.NamedBase.apply(this, arguments);

  this.sourceRoot(__dirname, 'templates');
}

util.inherits(Generator, yeoman.generatos.NamedBase);
</code></pre>

<p>First, notice that we are inheriting from <code>yeoman.Generators.NamedBase</code> instead<br />of <code>yeoman.Generators.Base</code>. This means that our generator expects at least one<br />argument, which will be the name of the initializer, and will be available in<br />our code in the variable <code>name</code>.</p>

<p>We can see that by invoking the description of this new generator:</p>

<pre><code>$ yeoman init initializer --help

Usage:
  yeoman init initializer NAME [options]
</code></pre>

<p><strong>Note</strong>: The banner is not automatically generated yet for generators (the Usage: thing above). Same for options and arguments defined by the generator,<br />they should show up during the help output. Right now, the USAGE file is dumped<br />to the console as is.</p>

<p>We can also see that our new generator has an instance method called <code>sourceRoot</code>.</p>

<p>This method points to where our generator templates will be placed, if any, and<br />by default it points to the created directory<br /><code>lib/generators/initializer/templates</code> (so the <code>sourceRoot(__dirname,<br />'templates')</code> can be removed, this is the default).</p>

<p>In order to understand what a generator template means, let’s create the file<br />lib/generators/initializer/templates/initializer.js with the following content:</p>

<pre><code>// Add initialization content here
</code></pre>

<p>And now let’s change the generator to copy this template when invoked:</p>

<pre><code>var util = require('util'),
    yeoman = require('../../../');

module.exports = Generator;

function Generator() {
  yeoman.generators.NamedBase.apply(this, arguments);
  // if your templates/ location differ, feel free to set it with sourceRoot()
}

util.inherits(Generator, yeoman.generatos.NamedBase);

Generator.prototype.copyInitializerFile = function() {
  this.copy('initializer.js', 'config/initializers/' + name + '.js');
};
</code></pre>

<p>And let’s execute our generator:</p>

<pre><code>$ yeoman generate initializer core_extensions
</code></pre>

<p>We can see that now an initializer named <code>core_extensions</code> was created at<br /><code>config/initializers/core_extensions.js</code> with the contents of our template. That<br />means that <code>copy</code> copied a file in our source root to the destination path<br />we gave. The property <code>name</code> is automatically created when we inherit from<br /><code>yeoman.Generators.NamedBase</code>, and match the value of the given argument<br />(<code>NamedBase</code> automatically specify an argument via <code>this.argument</code>)</p>

<h3>Generators Lookup</h3>

<p>When you run <code>yeoman generate initializer core_extensions</code> yeoman requires these<br />paths in turn until one is found:</p>

<pre><code>lib/generators/initializer/index.js
lib/generators/initializer.js
lib/generators/yeoman/initializer/index.js
lib/generators/yeoman/initializer.js
</code></pre>

<p><strong>Note</strong>: <code>index.js</code> may be anything else, as long the module entry point is<br />defined in a package.json.</p>

<p><strong>Seconc Note</strong>: While true, the help output might miss a generator. It looks<br />for file below lib/generators at few locations, searching for <code>index.js</code> files.</p>

<p>yeoman will do this lookup at few different places, in this order:</p>

<ul>
<li>relative to the working directory, from within a yeoman application.</li>
<li>relative to any <code>node_modules/yeoman-*</code> module. These are called "yeoman
plugins", they should package up their generator in the <code>lib/generators</code>
directory.</li>
</ul>

<p>This mean that users may override part or the whole set of generator used by<br />yeoman, either at an application level, with custom handcrafted generator or<br />via "yeoman plugin" (a node package that defines a set of generators in their<br /><code>lib/generators</code> directory).</p>

<p>If none is found you get an error message.</p>

<h3>Customizing your Workflow</h3>

<p>Yeoman own generators are flexible enough to let you customize scaffolding. They<br />can be configured in your application Gruntfile, these are some defaults:</p>

<pre><code>  generators: {
    'template-engine': 'handlebars',
    'test-framework': {
      name: 'mocha',
      options: {
        ui: 'bdd'
      }
    }
  }
</code></pre>

<p>Looking at this output, it’s easy to understand how generators work in yeoman.</p>

<p>Generator relies on hook and other generators, some don't actually generate<br />anything, they just invokes others to do the work.</p>

<p>This allows us to add/replace/remove any of those invocations. For instance,<br />the <code>controller</code> generator invokes the <code>view</code> and <code>test-framework</code> hooks. These<br />hooks tries to resolve their value from cli options first, then look at the<br />Gruntfile for a generator property with the corresponding hook name, and<br />finally defaults to the hook name if none were found.</p>

<p>Since each generator has a single responsibility, they are easy to reuse,<br />avoiding code duplication.</p>

<p><strong>TBD</strong> Finish up this section: example of running controller generator, see<br />the hooks. etc.</p>

<h3>Customizing Your Workflow by Changing Generators Templates</h3>

<p>In the step above we simply wanted to add a line to the generated helper,<br />without adding any extra functionality. There is a simpler way to do that, and<br />it’s by replacing the templates of already existing generators, in that case<br /><code>yeoman.generators.HelperGenerator</code>.</p>

<p>Generators don’t just look in the source root for templates, they also search<br />for templates in other paths. And one of them is lib/templates. Since we want<br />to customize <code>yeoman.generators.HelperGenerator</code>, we can do that by simply<br />making a template copy inside lib/templates/yeoman/helper with the name<br />helper.js.</p>

<p>If you generate another resource, you can see that we get exactly the same<br />result! This is useful if you want to customize your scaffold templates and/or<br />layout by just creating edit.html.erb, index.html.erb and so on inside<br />lib/templates/erb/scaffold.</p>

<h3>More On Generators</h3>

<p>So we know that a typical generator looks like the following:</p>

<pre><code>
var util = require('util'),
    yeoman = require('../../../');

module.exports = Generator;

function Generator() {
  yeoman.generators.NamedBase.apply(this, arguments);
}

util.inherits(Generator, yeoman.generators.NamedBase);

Generator.prototype.createSomething = function() {
  // code
};

// ... other methods ...
</code></pre>

<p>Generators can also be written in CofeeScript, they just needs to be named with<br />a <code>.coffee</code> extension (typically <code>lib/generators/generatorName/index.coffee</code>)</p>

<pre><code>
yeoman = require 'yeoman'

module.exports = class Generator extends yeoman.generators.NamedBase

  constructor: (args, options, config) ->
    super args, options, config

  createSomething: ->
    # code

  # ... other method ...
</code></pre>

<p>They're usually layout like so:</p>

<pre><code>lib/
└── generators
    └── generatorName
        ├── USAGE
        ├── index.js
        └── templates
</code></pre>

<p>Generators extends either <code>yeoman.generators.Base</code> or<br /><code>yeoman.generators.NamedBase</code>. <code>NamedBase</code> is suitable to use for genetors that<br />expects a "name" argument, such as <code>yeoman init model [NAME]</code>.</p>

<p>Every public method in a generator are executed serially. Every first level<br />method in the prototype chain, eg. inherited method in <code>Base</code> are not.</p>

<p>Two exceptions:</p>

<ul>
<li>any method beginning with <code>_</code> is not runned, you may use them as method
helper. They won't be called automatically on generator invokation.</li>
<li>a <code>constructor</code> method, most likely when using CoffeeScript to implement the generator</li>
</ul>

<p>Either <code>Name</code> or <code>BasedName</code> are EventEmitters, you may use the EventEmitter<br />API if you wish to (emit / on / once / ...)</p>

<h2>grunt.file</h2>

<p>Generators get mixed into their prototype the<br /><a href="https://github.com/cowboy/grunt/blob/master/docs/api_file.md#the-file-api">grunt.file</a><br />API. You can use read, readJSON, write, copy, mkdir, expandFiles, etc.</p>

<p>Note that some of them have special additional logic attached, for <code>copy</code>,<br /><code>read</code> and <code>write</code>.</p>

<p><code>copy</code> and <code>read</code> make sure to prefix the source filename to be within the<br />generator's source root (usually a <code>templates/</code> folder next to the generator<br />implementation).</p>

<h2>grunt.log</h2>

<p>In addition to the grunt.file API directly available into your generators, you<br />can use the<br /><a href="https://github.com/cowboy/grunt/blob/master/docs/api_log.md#the-log-api">grunt.log</a> API as <code>this.log</code></p>

<pre><code>
Generator.prototype.doingSomething = function() {
  this.log.writeln("I\m doing something");
  this.log.ok(".. And I think it's ok ..");
};
</code></pre>

<h2>sync vs async</h2>

<p>Methods are expected to run synchronously by default. This is fine for most<br />cases, and will be just what you need for most common operations. Every file<br />system method (copy, write, read, etc.) available are borrowed to grunt's,<br />where most of them are implemented synchronously for conveniency.</p>

<p>If you wish to run your method in an asynchronous way, you should tell the<br />system to do so. Very similarly to how you would handle async stuff in grunt<br />tasks.</p>

<p>If a method is asynchronous, <code>this.async</code> must be invoked to tell the system to<br />wait. It returns a handle to a "done" function that should be called when the<br />method has completed. Every non-falsy value (most likely an Error object) can<br />be passed to the done function as a first argument to indicate a failure.</p>

<p>It this method isn't invoked, the method executes synchronously.</p>

<h2>Generator methods</h2>

<p>The following are methods available for generators.</p>

<p>NOTE: Methods provided by Grunt are not covered this guide and can be found in<br />"Grunt's<br />documentation":<a href='https://github.com/cowboy/grunt/blob/master/docs/api_file.md#the-file-api'>https://github.com/cowboy/grunt/blob/master/docs/api_file.md#the-file-api</a></p>

<p><strong>TBD</strong></p>

<h2>Base Generator</h2>

<p>A <code>Base</code> generator has the following methods, members, and events.</p>

<h3>generator.options</h3>

<p>A hash object holding all cli parsed options by nopt.</p>

<h3>generator.argument(name, options)</h3>

<p>Adds an argument to the class and creates an instance property for it.</p>

<p>Arguments are different from options in several aspects. The first one<br />is how they are parsed from the command line, arguments are retrieved<br />from position:</p>

<pre><code>yeoman init NAME
</code></pre>

<p>Instead of:</p>

<pre><code>yeoman init --name NAME
</code></pre>

<p>Besides, arguments are used inside your code as a property (this.argument),<br />while options are all kept in a hash (this.options).</p>

<p>Options:</p>

<ul>
<li>desc     - Description for the argument.</li>
<li>required - If the argument is required or not.</li>
<li>optional - If the argument is optional or not.</li>
<li>type     - The type of the argument, can be String, Number, Array, Object
       (in which case considered as an Hash object, key:value).</li>
<li>defaults - Default value for this argument. It cannot be required
        and have default values.</li>
<li>banner   - String to show on usage notes.</li>
</ul>

<h3>generator.option(name, options)</h3>

<p>Adds an option to the set of generator expected options, only used to<br />generate generator usage. By default, generators get all the cli option<br />parsed by nopt as a this.options Hash object.</p>

<ul>
<li>name       - The name of the argument</li>
<li>options    - Hash of configuration values where:
<ul><li>desc     - Description for the argument.</li>
<li>type     - Type for this argument, either Boolean, String or Number.</li>
<li>defaults - Default value for this argument.</li>
<li>banner   - String to show on usage notes.</li>
<li>hide     - If you want to hide this option from the help.</li></ul></li>
</ul>

<h3>generator.sourceRoot([path])</h3>

<p>Stores and return the source root for this class. This is used with <code>copy()</code>,<br /><code>template()</code>, <code>read()</code>, etc. to prefix the relative path.</p>

<p>By default, takes the value of <code>templates/</code> next to the generator file.</p>

<p>When no path is given, returns the value of <code>_sourceRoot</code>.</p>

<h3>generator.destinationRoot([path])</h3>

<p>Sets the destination root for this class, ensure the directory is created and<br />cd into it.</p>

<h3>generator.hookFor(name, options)</h3>

<p>Must be called within the constructor only.</p>

<p>Register a hook to invoke a generator based on the value supplied by the user<br />to the given option named "name". An option is created when this method is<br />invoked and you can set a hash to customize it.</p>

<pre><code>
function MyGenerator(args, options, config) {
  yeoman.generators.Base.apply(this, arguments);
  // init a framework specific controller
  this.hookFor('js-framework');
}
</code></pre>

<p>Hooks work in a way that you can delegate the groundwork of scaffolding to<br />other generators. They're totally inspired by Rails 3 generators <a href="http://apidock.com/rails/Rails/Generators/Base/hook_for/class"><code>hook_for</code><br />method</a>.</p>

<p>The example above will create a js framework option and will invoke a<br />generator based on the user supplied value.</p>

<p>For example, if the user invokes the controller generator as:</p>

<pre><code>yeoman init controller Account --js-framework backbone
</code></pre>

<p>The controller generator will then try to invoke the following generators:</p>

<pre><code>"backbone:controller" "backbone"
</code></pre>

<p>Notice that the value of a given hook can be defined in your application Gruntfile as well:</p>

<pre><code>
// grunt config
generators: {
  'js-framework': 'backbone'
}
// ... more grunt config ...
</code></pre>

<p>This is what allows any js framework to hook into Yeoman as long as it provides<br />any of the hooks above.</p>

<h4>Options</h4>

<p>The first and last part used to find the generator to be invoked are guessed<br />based on constructor's <code>hookFor</code> invokes, as noticed in the example above. This<br />can be customized with the following options:</p>

<ul>
<li><code>as</code>      - the context to lookup, defaults to generator's name.</li>
<li><code>args</code>    - arguments to pass through, defaults generator's arguments.</li>
<li><code>options</code> - options to pass through, defaults to generator's options.</li>
<li><code>config</code>  - Grunt config to pass through, defaults to generator's config.</li>
</ul>

<p>Let’s suppose you are creating a generator that needs to invoke the controller<br />generator from a unit test. Your first attempt is:</p>

<pre><code>
// in lib/generators/awesome/index.js generator's constructor.
this.hookFor('test-framework');
</code></pre>

<p>The lookup in this case for test_unit as input is:</p>

<pre><code>"test_framework:awesome", "test_framework"
</code></pre>

<p>(more specifically, <code>"jasmine:awesome", jasmine"</code> which is the default value<br />for <code>test-framework</code> hook)</p>

<p>Which is not the desired lookup. You can change it by providing the <code>as</code> option:</p>

<pre><code>
// in lib/generators/awesome/index.js generator's constructor.
this.hookFor('test-framework', { as: 'controller' });
</code></pre>

<p>And now it will lookup at:</p>

<pre><code>"test_framework:controller", "test_framework"
</code></pre>

<h3>generator.copy(source, destination, options)</h3>

<blockquote>
  <p>Copy a source file to a destination path, creating intermediate directories if necessary.</p>
</blockquote>

<p>Grunt's<br /><a href="https://github.com/cowboy/grunt/blob/master/docs/api_file.md#grunt-file-copy"><code>grunt.file.copy</code></a><br />is used, we simply make sure that relative path are prefixed by the generator's<br />sourceRoot value.</p>

<pre><code>
// similar to
var source = path.join(this.sourceRoot(), 'path/to/file.js');
grunt.file.copy(source, destination, options);
</code></pre>

<h3>generator.read(filepath, [encoding])</h3>

<p>Same as copy, <code>.read()</code> relative <code>filepath</code> are prefixed by <code>self.sourceRoot()</code><br />value.</p>

<h3>generator.write(filepath, [encoding])</h3>

<blockquote>
  <p>Write the specified contents to a file, creating intermediate directories if necessary.</p>
</blockquote>

<p>Just like<br /><a href="https://github.com/cowboy/grunt/blob/master/docs/api_file.md#grunt-file-write"><code>grunt.file.write</code></a>,<br />we simply ensure the log output of the files being written.</p>

<pre><code>
// similar to
grunt.option('verbose', true);
grunt.file.write(filepath, encoding);
grunt.option('verbose', false);
</code></pre>

<h3>generator.template(source, [destination], [data])</h3>

<p>Gets an underscore template at the relative source, executes it and makes a<br />copy at the relative destination. If the destination is not given it's assumed<br />to be equal to the source relative to destination.</p>

<pre><code>
this.template('Gruntfile.js');
</code></pre>

<p>will copy and process the <code>templates/Gruntfile.js</code> file through<br /><code>grunt.template.process</code>, and write the results to <code>./Gruntfile.js</code> relative<br />the the application root.</p>

<p>Another example is using a <code>templates/model.js</code> template to write at the<br /><code>app/js/models/{name}-model.js</code> location in a <code>NamedBase</code> generator.</p>

<pre><code>
this.template('model.js', path.join('app/js/models', this.name + '-model.js'));
</code></pre>

<h3>generator.directory(source, [destination])</h3>

<p>Copies recursively the files from source directory to destination root<br />directory. If the destination is not given it's assumed<br />to be equal to the source relative to destination.</p>

<p>Each file is copied and processed through <code>grunt.template.process</code>.</p>

<pre><code>
this.directory('.', 'test');
</code></pre>

<p>The example above copies and process any files within generators <code>templates/</code><br />directory, and write them at the <code>test/</code> location.</p>

<h3>generator.tarball(url, destination, cb)</h3>

<p>Fetch a remote tarball, and untar at the given destination.</p>

<pre><code>
this.tarball('<a href='https://github.com/twitter/bootstrap/tarball/master'>https://github.com/twitter/bootstrap/tarball/master</a>', 'vendor/bootstrap', this.async());
</code></pre>

<h3>generator.fetch(url, destination, cb)</h3>

<p>Download a single file at the given destination.</p>

<pre><code>
this.fetch('<a href='http://zeptojs.com/zepto.js'>http://zeptojs.com/zepto.js</a>', 'js/vendor/zepto.js', this.async());
</code></pre>

<h3>generator.remote(username, repository, [branch], cb)</h3>

<p>Remotely fetch a package on github, store this into an internal <code>_cache/</code><br />folder, and invokes provided callback on completion with a "remote" object as<br />the main API to interract with downloaded package.</p>

<ul>
<li>username      - GitHub username</li>
<li>repository    - GitHub repository to fetch from</li>
<li>branch        - Optional branch or sha1, defaults to master</li>
<li>cb            - function to invoke on completion</li>
</ul>

<p>The example below downloads and cache the html5-boilerplate project, and use the <code>remote</code> object<br />to copy the whole project into the <code>app/</code> folder.</p>

<pre><code>
var cb = this.async();
this.remote('h5bp', 'html5-boilerplate', 'master', function(err, remote) {
  if(err) return cb(err);
  // remote.copy('index.html', 'index.html');
  // remote.template('index.html', 'will/be/templated/at/index.html');
  remote.directory('.', 'app');
  cb();
});
</code></pre>

<p><code>remote()</code> allows the download of full repositories and copying of single or<br />multiple files. <code>remote</code> object is your API to access this fetched (anc cached)<br />package and copy / process files.</p>

<h4>remote.copy(source, destination, options)</h4>

<p>Same as <code>generator.copy()</code> but relative <code>source</code> is prefixed with the cache<br />directory.</p>

<h4>remote.template(source, destination, options)</h4>

<p>Same as <code>generator.temlate()</code> but relative <code>source</code> is prefixed with the cache<br />directory.</p>

<h4>remote.template(source, destination, options)</h4>

<p>Same as <code>generator.directory()</code> but relative <code>source</code> is prefixed with the cache directory.</p>

<h4>Prompt user before overwriting files with <code>--force</code></h4>

<p>Generators also support a <code>warnOn</code> method, which allows developers to warn on global paths that are matching those paths or files which the generator is going to generate (e.g <code>self.warnOn('*')</code>. </p>

<p>Where used, Yeoman will warn the user they if they proceed that a file will be overwritten and they may need to call the generator with the <code>--force</code> flag to proceed.</p>

<p><code>warnOn</code> is most likely to be used in constructors.</p>

<h2><a href="#modules" name="modules">EcmaScript 6 Modules And Module Support</a></h2>

<p>Note: This content is subject to change and may be removed prior to launch.</p>

<p>Yeoman comes with experimental support for ES6 modules, made possible through Require HM. HM allows us to write ES.next module syntax and as long as code is saved in files with <code>.hm</code> extension, they can be used with RequireJS and AMD as if they were regular ES3/5 scripts.</p>

<p>*Note: The ES.next module specification is not yet complete and is subject to change. As such, the material below should be considered correct as of June, 2012 but for later dates the Harmony wiki entry on modules should be consulted to ensure correctness.</p>

<p>Also note that as Require HM is a RequireJS plugin, ES6 modules are only supported when used with RequireJS. We hope to change this in the future once support for ES6 modules in Google Traceur has improved.*</p>

<h3>module:</h3>

<p>In ES6, A module is a unit of code contained within a <code>module</code> declaration. It can either be defined inline or within an externally loaded module file. A skeleton inline module for a Car could be written:</p>

<pre><code>
module Car{
  // import …
  // export …
}
</code></pre>

<p>When we say <em>externally loaded modules</em>, we are referring to modules which are either loaded using <code>import</code> declarations or the Module Loader API. Both will be covered shortly.</p>

<p>A module <em>instance</em> is a module which has been evaluated, is linked to other modules or has lexically encapsulated data. Examples of modules instances are:</p>

<pre><code>
module myCar = Car;
module myCar at "car.js";
</code></pre>

<p><code>module</code> declarations can be used in the following contexts:</p>

<pre><code>
module Universe {}
module Universe { module MilkyWay {} }
module MilkyWay = "Universe/MilkyWay"
module System = Universe.MilkyWay.SolarSystem
module System = SolarSystem

</code></pre>

<h3>export:</h3>

<p>An export declaration declares that a local function or variable binding is visible externally to other modules. If familiar with the module pattern, think of this concept as being parallel to the idea of exposing functionality publicly.</p>

<pre><code>
module Car{

  // Internals
  var licensePlateNo = "556-343"

  // Exports
  export function drive(speed, direction){
    console.log('We are driving at a speed of ' + speed + ', ' + direction);
  }

  export var miles = 5000;
  export var color = "silver";
}

</code></pre>

<p>Modules <code>import</code> what they wish to use from other modules. Other modules may read the module exports (e.g <code>drive()</code>, <code>miles</code> etc. above) but they cannot modify them. Exports can be renamed as well so their names are different from local names.</p>

<p>A module may also export other modules for consumption.</p>

<pre><code>
module Car{
  export module engine{}
  export module driver{}
  export module seats{}
}
</code></pre>

<p><code>export</code> can be used in the following contexts:</p>

<pre><code>
export var document
export var document = { }
export function parse() { }
export module System = SolarSystem
export SolarSystem
export Mercury, Venus, Earth
export * from SolarSystem
export { Mercury: SolarSystem.Mercury, Earth: SolarSystem.Earth }
</code></pre>

<h3>import:</h3>

<p>An import declaraction binds another modules exports as local variables. Variables that are imported can be locally renamed to avoid naming conflicts.</p>

<pre><code>
module Car{
  export function drive(speed, direction){
    console.log('details:', speed, direction);
  }

  export module engine{
    export function check(){ ... }
  }

  export var miles = 5000;
  export var color = "silver";

};
</code></pre>

<p>Revisiting the export example above, we can now selectively choose what we wish to <code>import</code> when in another module.</p>

<p>We can just import <code>drive()</code>:</p>

<pre><code>
import drive from Car;
</code></pre>

<p>We can import <code>drive()</code> and <code>miles</code>:</p>

<pre><code>
import {drive, miles} from Car;
</code></pre>

<p>We can import <code>check()</code> from our engine module:</p>

<pre><code>
import check from Car.engine;
</code></pre>

<p>We can import all of the exports:</p>

<pre><code>
import * from Car;
</code></pre>

<p>We can also import an entire file as a module:</p>

<pre><code>
import "car.js" as Car;
</code></pre>

<p>Or import <code>drive()</code> without needing to bind the module to a local name:</p>

<pre><code>
import drive from "car.js";
</code></pre>

<p>This similarly works with JavaScript libraries like Underscore.js:</p>

<pre><code>
import reduce from "Underscore.js"
</code></pre>

<h3>module, import and export</h3>

<p>Bringing these three concepts together:</p>

<pre><code>
module vehicle{
  export function drive(speed, direction){
    console.log('We are driving at a speed of ' + speed + ', ' + direction);
  };

  export function stop(){
    console.log('We have stopped');
  };

  export var miles = 0;
  export var color = "silver";
  export var wheels = 4;
}

module basicExtras{
  export var carSeat = true;
  export var specialRims =  true;
  export var mp3Player = true;
}

module premiumExtras{
  export module GPS{
    //...
  }
}

</code></pre>

<pre><code>
// Engine.js
module engine{

}
</code></pre>

<pre><code>
module Car{
  import * from vehicle;
  import {specialRims, mp3Player} from basicExtras;
  import "engine.js" as engine;
  module navigationSystem from premiumExtras.GPS;

  export drive;
  export stop;
}
</code></pre>

<p>-- how do you rename exports?</p>

<h3>dynamically loading modules</h3>

<p>Earlier, we mentioned the concept of a Module Loader API. The module loader allows us to dynamically load in scripts for consumption. Similar to <code>import</code>, we are able to consume anything defined as an <code>export</code> from such modules.</p>

<pre><code>
// Signature: load( moduleURL, callback, errorCallback )

Loader.load("car.js", function(car) {
        console.log(car.drive(500, "north"));
    }, function(err){
        console.log("Error:" + err);
    });

</code></pre>

<p><code>load()</code> accepts three arguments:</p>

<ul>
<li>moduleURL: The string representing a module URL (e.g "car.js")</li>
<li>callback: A callback function which receives the output result of attempting to load, compile and then execute the module</li>
<li>errorCallback: A callback triggered if an error occurs during loading or compilation</li>
</ul>

<p>Whilst the above example seems fairly trivial to use, the Loader API is there to provide a way to load modules in controlled contexts and actually supports a number of different configuration options. <code>Loader</code> itself is a system provided instance of the API, but it's possible to create custom loaders using the <code>Loader</code> constructor.</p>

<pre><code>
// The Loader constructor creates a new loader
var customLoader = new Loader(
    // Define the parent of this loader
    // if a custo one exists, otherwise
    // just use the default system Loader
    Loader, {

    // Global object for the Loader
    global: Object.create(null),

    // Loader's base URL
    baseURL: baseURL,

    // A flag indicating whether code should be evaluated
    // in strict mode
    strict: false,

    // Source of the loader intrinsics which can either
    // be an existing loader or just null
    linkedTo: Loader || null,

    // The module resolution hook
    resolve: function( relativeURL, baseURL ){..},

    // The module loading hook
    fetch: function( relativeURL, baseURL, request, resolved ){…},

    // A hook for source translation
    translate: function( src, relativeURL, baseURL, resolved ){…}
});
</code></pre>

<p>Let's review the final three hooks in more detail:</p>

<p><strong>fetch: function( relativeURL, baseURL, request, resolved ):</strong></p>

<p>Once a module is resolved, it must be fetched. The <code>fetch</code> hook allows us to fetch code from an external resource and returns its source via the first callback or rejecting the code via the second callback.</p>

<p>The <code>fetch</code> request object has three callbacks:</p>

<pre><code>
request = {

  // callbacks for the loading hook

  // callback to create the successfully loaded source
  fulfill: function( src ){..},

  // callback to indicate the source should be loaded from a different URL
  redirect: function( url, baseURL ){..}

  // callback to indicate am error occurred in the loading
  reject: function( msg )
}
</code></pre>

<p>If we don't supply a <code>fetch</code> hook, the parent Loader's <code>fetch</code> is used instead.</p>

<p><strong>resolve: function( relativeURL, baseURL ):</strong></p>

<p><strong>translate: function( src, relativeURL, baseURL, resolved ):</strong></p>

<p>When code is evaluated, we have the option of translating the source of that code using this hook. The hook can either produce the final source code or throw an exception if something goes wrong.</p>

<p>A complete custom loader example could thus be written as follows:</p>

<pre><code>
var customLoader = new Loader(Loader,{
    global: window,
    baseURL: document.URL.substring(0, document.URL.lastIndexOf('\/') + 1),
    strict: false,
    resolve: function (relURL, baseURL) {
      var url = baseURL + relURL;
      return url;
    },
    fetch: function (relURL, baseURL, request, resolved) {
      var url = baseURL + relURL;
      var xhr = new XMLHttpRequest();
      xhr.onreadystatechange = function () {
        if (xhr.readyState === 4) {
          if (xhr.status === 200) {
            request.fulfill(xhr.responseText);
          } else {
            request.reject(xhr.statusText);
          }
        }
      };
      xhr.open("GET", url, true);
      xhr.send(null);
    },
    translate: function (src, relURL, baseURL, resolved) {
      return src;
    }
  });
</code></pre>

<p><em>Note: As Require HM is able to work with the RequireJS <code>define()</code> and <code>require()</code> syntax, it doesn't currently support the Module Loader API. If one is however required, there is a shim available for this feature <a href="https://github.com/addyosmani/es6-module-loader/">here</a>.</em></p>

<h3>What else can be done with modules?</h3>

<p>We can also define modules with a shared state:</p>

<pre><code>
module Car{
  export module milesCounter {
      var miles = 0;
      export function addMile() { return miles++ }
      export function currentMiles() { return miles }
  };
};
</code></pre>

<p>or cyclic dependencies:</p>

<pre><code>
module Car {
    import * from Scooter;
    export function even(n) {
        return n == 0 || odd(n - 1);
    }
}

module Scooter {
    import * from Car;
    export function odd(n) {
        return n != 0 && even(n - 1);
    }
}
</code></pre>

<p><em>Note: Require HM does not presently support cyclic dependencies. We are working on fixing this limitation.</em></p>
<img src="img/yeoman-006.png" class="character"/>      </section>
    </article>
  </div>
</body>
</html>